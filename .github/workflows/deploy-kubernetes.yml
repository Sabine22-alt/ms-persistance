name: Deploy Kubernetes

on:
  workflow_call:
    inputs:
      image-tag:
        required: true
        type: string
    outputs:
      service-url:
        description: "Service URL"
        value: ${{ jobs.deploy.outputs.service-url }}

env:
  IMAGE_NAME: ms-persistance
  NAMESPACE: ms-persistance-integration

jobs:
  deploy:
    name: Deploy to Kubernetes (Minikube)
    runs-on: ubuntu-22.04
    timeout-minutes: 20
    outputs:
      service-url: ${{ steps.endpoint.outputs.service_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: ./

      - name: Setup Minikube and load image
        run: |
          # Installation rapide de Minikube
          curl -sLO https://storage.googleapis.com/minikube/releases/v1.32.0/minikube-linux-amd64
          sudo install minikube-linux-amd64 /usr/local/bin/minikube && rm minikube-linux-amd64
          
          # DÃ©marrage de Minikube
          minikube start --driver=docker --memory=3072 --cpus=2 --kubernetes-version=v1.28.0
          
          # Configuration kubectl
          kubectl config use-context minikube
          
          # Attendre que le cluster soit prÃªt
          echo "â³ Waiting for cluster to be ready..."
          sleep 10
          
          # VÃ©rifier que CoreDNS est dÃ©ployÃ© et prÃªt
          echo "â³ Waiting for CoreDNS pods to be created..."
          for i in {1..30}; do
            if kubectl get pods -n kube-system -l k8s-app=kube-dns 2>/dev/null | grep -q "coredns"; then
              echo "CoreDNS pods found, waiting for ready state..."
              kubectl wait --for=condition=ready pod -l k8s-app=kube-dns -n kube-system --timeout=120s && break
            fi
            echo "Waiting for CoreDNS pods... ($i/30)"
            sleep 3
          done
          
          echo "ðŸ“‹ Cluster status:"
          kubectl get pods -n kube-system
          
          # Charger l'image
          echo "ðŸ“¥ Loading Docker image..."
          minikube image load app-image.tar
          minikube image tag ${{ env.IMAGE_NAME }}:${{ inputs.image-tag }} ${{ env.IMAGE_NAME }}:latest
          
          echo "âœ… Minikube ready with image loaded"

      - name: Deploy infrastructure and application
        run: |
          # CrÃ©er namespace
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          
          # DÃ©ployer tout en une seule commande
          kubectl apply -f k8s/minikube/ -n ${{ env.NAMESPACE }}
          
          echo "âœ… All manifests applied"

      - name: Wait for dependencies (MySQL & MinIO)
        run: |
          echo "â³ Waiting for MySQL and MinIO..."
          
          # Attendre un peu que les pods soient crÃ©Ã©s
          sleep 10
          
          # Attendre MySQL (timeout 90s)
          kubectl wait --for=condition=ready pod -l app=mysql -n ${{ env.NAMESPACE }} --timeout=90s &
          MYSQL_PID=$!
          
          # Attendre MinIO (timeout 120s car PVC + image pull peuvent Ãªtre lents)
          kubectl wait --for=condition=ready pod -l app=minio -n ${{ env.NAMESPACE }} --timeout=120s &
          MINIO_PID=$!
          
          # Attendre MySQL
          wait $MYSQL_PID || { 
            echo "âŒ MySQL timeout"
            kubectl describe pod -l app=mysql -n ${{ env.NAMESPACE }}
            kubectl logs -l app=mysql -n ${{ env.NAMESPACE }} --tail=30
            exit 1
          }
          echo "âœ… MySQL ready"
          
          # Attendre MinIO
          wait $MINIO_PID || { 
            echo "âŒ MinIO timeout"
            kubectl describe pod -l app=minio -n ${{ env.NAMESPACE }}
            kubectl logs -l app=minio -n ${{ env.NAMESPACE }} --tail=30
            exit 1
          }
          echo "âœ… MinIO ready"
          
          echo "âœ… All dependencies ready"

      - name: Wait for application deployment
        run: |
          echo "â³ Waiting for ms-persistance rollout..."
          
          # VÃ©rifier que les services sont accessibles
          echo "ðŸ“‹ Services:"
          kubectl get svc -n ${{ env.NAMESPACE }}
          
          # Attendre le rollout avec timeout de 180s
          kubectl rollout status deployment/ms-persistance -n ${{ env.NAMESPACE }} --timeout=180s || {
            echo "âŒ Rollout failed"
            echo ""
            echo "ðŸ“‹ Pods status:"
            kubectl get pods -n ${{ env.NAMESPACE }} -o wide
            echo ""
            echo "ðŸ“‹ Pod logs:"
            kubectl logs -l app=ms-persistance -n ${{ env.NAMESPACE }} --tail=100 || true
            echo ""
            echo "ðŸ“‹ Pod describe:"
            kubectl describe pods -l app=ms-persistance -n ${{ env.NAMESPACE }}
            exit 1
          }
          echo "âœ… Application deployed"

      - name: Setup port-forward and test health
        id: endpoint
        run: |
          # DÃ©marrer port-forward
          nohup kubectl port-forward svc/ms-persistance 8090:8090 -n ${{ env.NAMESPACE }} > /tmp/pf.log 2>&1 &
          
          # Attendre que le port soit ouvert (max 15s)
          for i in {1..15}; do
            nc -z localhost 8090 2>/dev/null && break
            sleep 1
          done
          
          SERVICE_URL="http://localhost:8090"
          echo "service_url=$SERVICE_URL" >> $GITHUB_OUTPUT
          
          # Health check rapide (max 60s au lieu de 75s)
          for i in {1..12}; do
            if curl -sf --connect-timeout 5 "$SERVICE_URL/actuator/health" >/dev/null 2>&1; then
              echo "âœ… Service healthy at $SERVICE_URL"
              exit 0
            fi
            sleep 5
          done
          
          echo "âŒ Health check failed"
          cat /tmp/pf.log || true
          kubectl logs -l app=ms-persistance -n ${{ env.NAMESPACE }} --tail=50
          exit 1

      - name: Run Newman integration tests
        working-directory: ./tests/newman
        run: |
          # Installation et configuration Newman en parallÃ¨le
          npm install --silent &
          NPM_PID=$!
          
          # Configurer l'environnement
          SERVICE_URL="${{ steps.endpoint.outputs.service_url }}"
          jq --arg url "$SERVICE_URL" \
            '(.values[] | select(.key == "baseUrl") | .value) = $url' \
            env.json > env.tmp.json
          
          wait $NPM_PID
          
          # VÃ©rifier port-forward
          nc -z localhost 8090 || {
            nohup kubectl port-forward svc/ms-persistance 8090:8090 -n ${{ env.NAMESPACE }} > /tmp/pf.log 2>&1 &
            sleep 3
          }
          
          mkdir -p newman-results
          
          npx newman run ./collection.json \
            --environment ./env.tmp.json \
            --iteration-data ./dataset.json \
            --reporters cli,json \
            --reporter-json-export ./newman-results/newman-report.json \
            --timeout-request 20000 \
            --bail || {
              echo "âŒ Tests failed"
              kubectl logs -l app=ms-persistance -n ${{ env.NAMESPACE }} --tail=50
              exit 1
            }
          
          echo "âœ… All tests passed!"

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: newman-results
          path: tests/newman/newman-results/
          retention-days: 5

      - name: Upload service URL artifact
        if: always()
        run: |
          echo "${{ steps.endpoint.outputs.service_url }}" > service-url.txt

      - name: Upload service URL
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: service-url
          path: service-url.txt
          retention-days: 5

      - name: Debug info on failure
        if: failure()
        run: |
          echo "=== Pods ==="
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide
          echo "=== Events ==="
          kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp' | tail -20
          echo "=== App Logs ==="
          kubectl logs -l app=ms-persistance -n ${{ env.NAMESPACE }} --tail=100 || true


