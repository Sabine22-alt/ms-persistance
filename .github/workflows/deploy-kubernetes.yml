name: Deploy Kubernetes

on:
  workflow_call:
    inputs:
      image-tag:
        required: true
        type: string
    outputs:
      service-url:
        description: "Service URL"
        value: ${{ jobs.deploy.outputs.service-url }}

env:
  IMAGE_NAME: ms-persistance
  NAMESPACE: ms-persistance-integration

jobs:
  deploy:
    name: Deploy to Kubernetes (Minikube)
    runs-on: ubuntu-22.04
    timeout-minutes: 20
    outputs:
      service-url: ${{ steps.endpoint.outputs.service_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: ./

      - name: Setup Minikube and load image
        run: |
          # Installation rapide de Minikube
          curl -sLO https://storage.googleapis.com/minikube/releases/v1.32.0/minikube-linux-amd64
          sudo install minikube-linux-amd64 /usr/local/bin/minikube && rm minikube-linux-amd64
          
          # D√©marrage optimis√© - moins de m√©moire, d√©sactivation des addons inutiles
          minikube start --driver=docker --memory=3072 --cpus=2 --kubernetes-version=v1.28.0 \
            --extra-config=kubeadm.skip-phases=addon/kube-proxy \
            --disable-metrics
          
          # Configuration kubectl
          kubectl config use-context minikube
          
          # Charger l'image pendant que le cluster d√©marre
          echo "üì• Loading Docker image..."
          minikube image load app-image.tar
          minikube image tag ${{ env.IMAGE_NAME }}:${{ inputs.image-tag }} ${{ env.IMAGE_NAME }}:latest
          
          echo "‚úÖ Minikube ready with image loaded"

      - name: Deploy infrastructure and application
        run: |
          # Cr√©er namespace
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          
          # D√©ployer tout en une seule commande
          kubectl apply -f k8s/minikube/ -n ${{ env.NAMESPACE }}
          
          echo "‚úÖ All manifests applied"

      - name: Wait for dependencies (MySQL & MinIO)
        run: |
          echo "‚è≥ Waiting for MySQL and MinIO..."
          
          # Attendre un peu que les pods soient cr√©√©s
          sleep 10
          
          # Attendre MySQL (timeout 90s)
          kubectl wait --for=condition=ready pod -l app=mysql -n ${{ env.NAMESPACE }} --timeout=90s &
          MYSQL_PID=$!
          
          # Attendre MinIO (timeout 120s car PVC + image pull peuvent √™tre lents)
          kubectl wait --for=condition=ready pod -l app=minio -n ${{ env.NAMESPACE }} --timeout=120s &
          MINIO_PID=$!
          
          # Attendre MySQL
          wait $MYSQL_PID || { 
            echo "‚ùå MySQL timeout"
            kubectl describe pod -l app=mysql -n ${{ env.NAMESPACE }}
            kubectl logs -l app=mysql -n ${{ env.NAMESPACE }} --tail=30
            exit 1
          }
          echo "‚úÖ MySQL ready"
          
          # Attendre MinIO
          wait $MINIO_PID || { 
            echo "‚ùå MinIO timeout"
            kubectl describe pod -l app=minio -n ${{ env.NAMESPACE }}
            kubectl logs -l app=minio -n ${{ env.NAMESPACE }} --tail=30
            exit 1
          }
          echo "‚úÖ MinIO ready"
          
          echo "‚úÖ All dependencies ready"

      - name: Wait for application deployment
        run: |
          echo "‚è≥ Waiting for ms-persistance rollout..."
          
          # V√©rifier que les services sont accessibles
          echo "üìã Services:"
          kubectl get svc -n ${{ env.NAMESPACE }}
          
          # Attendre le rollout avec timeout de 240s
          kubectl rollout status deployment/ms-persistance -n ${{ env.NAMESPACE }} --timeout=240s || {
            echo "‚ùå Rollout failed"
            echo ""
            echo "üìã Pods status:"
            kubectl get pods -n ${{ env.NAMESPACE }} -o wide
            echo ""
            echo "üìã Init containers logs:"
            POD=$(kubectl get pods -l app=ms-persistance -n ${{ env.NAMESPACE }} -o jsonpath='{.items[0].metadata.name}')
            kubectl logs $POD -c wait-for-mysql -n ${{ env.NAMESPACE }} || true
            kubectl logs $POD -c wait-for-minio -n ${{ env.NAMESPACE }} || true
            echo ""
            echo "üìã Pod describe:"
            kubectl describe pod $POD -n ${{ env.NAMESPACE }}
            exit 1
          }
          echo "‚úÖ Application deployed"

      - name: Setup port-forward and test health
        id: endpoint
        run: |
          # D√©marrer port-forward
          nohup kubectl port-forward svc/ms-persistance 8090:8090 -n ${{ env.NAMESPACE }} > /tmp/pf.log 2>&1 &
          
          # Attendre que le port soit ouvert (max 15s)
          for i in {1..15}; do
            nc -z localhost 8090 2>/dev/null && break
            sleep 1
          done
          
          SERVICE_URL="http://localhost:8090"
          echo "service_url=$SERVICE_URL" >> $GITHUB_OUTPUT
          
          # Health check rapide (max 60s au lieu de 75s)
          for i in {1..12}; do
            if curl -sf --connect-timeout 5 "$SERVICE_URL/actuator/health" >/dev/null 2>&1; then
              echo "‚úÖ Service healthy at $SERVICE_URL"
              exit 0
            fi
            sleep 5
          done
          
          echo "‚ùå Health check failed"
          cat /tmp/pf.log || true
          kubectl logs -l app=ms-persistance -n ${{ env.NAMESPACE }} --tail=50
          exit 1

      - name: Run Newman integration tests
        working-directory: ./tests/newman
        run: |
          # Installation et configuration Newman en parall√®le
          npm install --silent &
          NPM_PID=$!
          
          # Configurer l'environnement
          SERVICE_URL="${{ steps.endpoint.outputs.service_url }}"
          jq --arg url "$SERVICE_URL" \
            '(.values[] | select(.key == "baseUrl") | .value) = $url' \
            env.json > env.tmp.json
          
          wait $NPM_PID
          
          # V√©rifier port-forward
          nc -z localhost 8090 || {
            nohup kubectl port-forward svc/ms-persistance 8090:8090 -n ${{ env.NAMESPACE }} > /tmp/pf.log 2>&1 &
            sleep 3
          }
          
          mkdir -p newman-results
          
          npx newman run ./collection.json \
            --environment ./env.tmp.json \
            --iteration-data ./dataset.json \
            --reporters cli,json \
            --reporter-json-export ./newman-results/newman-report.json \
            --timeout-request 20000 \
            --bail || {
              echo "‚ùå Tests failed"
              kubectl logs -l app=ms-persistance -n ${{ env.NAMESPACE }} --tail=50
              exit 1
            }
          
          echo "‚úÖ All tests passed!"

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: newman-results
          path: tests/newman/newman-results/
          retention-days: 5

      - name: Debug info on failure
        if: failure()
        run: |
          echo "=== Pods ==="
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide
          echo "=== Events ==="
          kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp' | tail -20
          echo "=== App Logs ==="
          kubectl logs -l app=ms-persistance -n ${{ env.NAMESPACE }} --tail=100 || true


