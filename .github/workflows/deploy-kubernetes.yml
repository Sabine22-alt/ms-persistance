name: CD - Deploy to Kubernetes

on:
  workflow_run:
    workflows: ["CI - Build and Push"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install OCI CLI
        run: |
          echo "Installation d'OCI CLI..."
          curl -L https://raw.githubusercontent.com/oracle/oci-cli/master/scripts/install/install.sh -o install.sh
          chmod +x install.sh
          ./install.sh --accept-all-defaults
          echo "$HOME/bin" >> $GITHUB_PATH
          echo "‚úÖ OCI CLI install√©"

      - name: Configure OCI CLI
        run: |
          echo "Configuration d'OCI CLI..."
          
          # Cr√©er le r√©pertoire de configuration
          mkdir -p ~/.oci
          
          # √âcrire la cl√© priv√©e (pr√©server les retours √† la ligne)
          echo "${{ secrets.OCI_API_KEY }}" > ~/.oci/oci_api_key.pem
          
          # V√©rification du format de la cl√©
          if ! grep -q "BEGIN RSA PRIVATE KEY" ~/.oci/oci_api_key.pem; then
            echo "‚ùå Erreur: Format de cl√© OCI invalide"
            echo "La cl√© doit commencer par '-----BEGIN RSA PRIVATE KEY-----'"
            exit 1
          fi
          
          if ! grep -q "END RSA PRIVATE KEY" ~/.oci/oci_api_key.pem; then
            echo "‚ùå Erreur: Format de cl√© OCI invalide"
            echo "La cl√© doit se terminer par '-----END RSA PRIVATE KEY-----'"
            exit 1
          fi
          
          # Permissions strictes (obligatoire pour OCI)
          chmod 600 ~/.oci/oci_api_key.pem
          
          # Cr√©er le fichier de configuration OCI
          cat > ~/.oci/config << EOF
          [DEFAULT]
          user=${{ secrets.OCI_CLI_USER }}
          fingerprint=${{ secrets.OCI_CLI_FINGERPRINT }}
          tenancy=${{ secrets.OCI_CLI_TENANCY }}
          region=${{ secrets.OCI_CLI_REGION }}
          key_file=~/.oci/oci_api_key.pem
          EOF
          
          # Permissions pour le fichier de config
          chmod 600 ~/.oci/config
          
          echo "‚úÖ Configuration OCI cr√©√©e"
          
          # Afficher la config (sans donn√©es sensibles)
          echo "Configuration OCI (masqu√©e) :"
          echo "- User: ${OCI_CLI_USER:0:20}..."
          echo "- Tenancy: ${OCI_CLI_TENANCY:0:20}..."
          echo "- Region: ${{ secrets.OCI_CLI_REGION }}"
        env:
          OCI_CLI_USER: ${{ secrets.OCI_CLI_USER }}
          OCI_CLI_TENANCY: ${{ secrets.OCI_CLI_TENANCY }}

      - name: Test OCI CLI Connection
        run: |
          echo "Test de la connexion OCI..."
          
          # Test avec timeout
          timeout 30s oci iam region list --query "data[0].name" --raw-output || {
            echo "‚ùå √âchec du test de connexion OCI"
            echo ""
            echo "üîç V√©rifications n√©cessaires :"
            echo "1. OCI_CLI_USER : OCID de l'utilisateur"
            echo "2. OCI_CLI_FINGERPRINT : Fingerprint de la cl√© API"
            echo "3. OCI_CLI_TENANCY : OCID du tenancy"
            echo "4. OCI_CLI_REGION : R√©gion OCI (ex: eu-frankfurt-1)"
            echo "5. OCI_API_KEY : Cl√© priv√©e au format PEM avec retours √† la ligne"
            echo ""
            echo "üìö Documentation :"
            echo "https://docs.oracle.com/en-us/iaas/Content/API/Concepts/apisigningkey.htm"
            exit 1
          }
          
          echo "‚úÖ Connexion OCI √©tablie avec succ√®s"

      - name: Setup Kubernetes Config
        run: |
          echo "Configuration de kubectl pour OKE..."
          
          # Cr√©er le kubeconfig avec OCI CLI
          mkdir -p ~/.kube
          
          oci ce cluster create-kubeconfig \
            --cluster-id "${{ secrets.OKE_CLUSTER_ID }}" \
            --file ~/.kube/config \
            --region "${{ secrets.OCI_CLI_REGION }}" \
            --token-version 2.0.0 \
            --kube-endpoint PUBLIC_ENDPOINT
          
          chmod 600 ~/.kube/config
          
          echo "‚úÖ Kubeconfig configur√©"

      - name: Verify Kubernetes Connection
        run: |
          echo "V√©rification de la connexion au cluster Kubernetes..."
          
          kubectl cluster-info || {
            echo "‚ùå Impossible de se connecter au cluster OKE"
            echo "V√©rifiez OKE_CLUSTER_ID dans les secrets GitHub"
            exit 1
          }
          
          kubectl get nodes
          
          echo "‚úÖ Connexion au cluster OKE √©tablie"

      - name: Create Namespace if not exists
        run: |
          NAMESPACE="smartdish"
          
          if kubectl get namespace "$NAMESPACE" &> /dev/null; then
            echo "‚úÖ Namespace '$NAMESPACE' existe d√©j√†"
          else
            echo "Cr√©ation du namespace '$NAMESPACE'..."
            kubectl create namespace "$NAMESPACE"
            echo "‚úÖ Namespace '$NAMESPACE' cr√©√©"
          fi

      - name: Apply Kubernetes Manifests
        run: |
          echo "D√©ploiement des manifests Kubernetes..."
          
          # Remplacer les variables d'environnement dans les manifests
          export IMAGE_TAG="${{ github.sha }}"
          export MYSQL_ROOT_PASSWORD="${{ secrets.MYSQL_ROOT_PASSWORD }}"
          export MYSQL_DATABASE="${{ secrets.MYSQL_DATABASE }}"
          export MONGO_ROOT_USERNAME="${{ secrets.MONGO_ROOT_USERNAME }}"
          export MONGO_ROOT_PASSWORD="${{ secrets.MONGO_ROOT_PASSWORD }}"
          
          # Appliquer les manifests
          envsubst < k8s/deployment.yaml | kubectl apply -f - -n smartdish
          kubectl apply -f k8s/service.yaml -n smartdish
          
          echo "‚úÖ Manifests Kubernetes appliqu√©s"

      - name: Wait for Deployment Rollout
        run: |
          echo "Attente du d√©ploiement complet..."
          
          kubectl rollout status deployment/smartdish-app -n smartdish --timeout=5m || {
            echo "‚ùå Le d√©ploiement a √©chou√©"
            echo ""
            echo "üìã Logs des pods :"
            kubectl logs -l app=smartdish-app -n smartdish --tail=50
            echo ""
            echo "üìä √âtat des pods :"
            kubectl get pods -n smartdish
            echo ""
            echo "üîç Description du d√©ploiement :"
            kubectl describe deployment smartdish-app -n smartdish
            exit 1
          }
          
          echo "‚úÖ D√©ploiement r√©ussi"

      - name: Display Deployment Info
        run: |
          echo "=========================================="
          echo "üì¶ INFORMATIONS DE D√âPLOIEMENT"
          echo "=========================================="
          echo ""
          echo "üè∑Ô∏è  Image d√©ploy√©e: ghcr.io/${{ github.repository }}:${{ github.sha }}"
          echo "üåç Namespace: smartdish"
          echo "üìÖ Date: $(date)"
          echo ""
          echo "=========================================="
          echo "üìä √âTAT DES RESSOURCES"
          echo "=========================================="
          kubectl get all -n smartdish
          echo ""
          echo "=========================================="
          echo "üîó SERVICES EXPOS√âS"
          echo "=========================================="
          kubectl get svc -n smartdish
          echo ""
          echo "‚úÖ D√©ploiement CD termin√© avec succ√®s"

      - name: Notify Deployment Status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ D√©ploiement r√©ussi sur Kubernetes/OKE"
          else
            echo "‚ùå √âchec du d√©ploiement sur Kubernetes/OKE"
          fi